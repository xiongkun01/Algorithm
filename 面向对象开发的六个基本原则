面向对象开发的六个基本原则：
单一职责；
里氏替换；
依赖倒置：面向接口编程；
接口隔离;
开放封闭；
合成聚合复用；

select * from table order by id limit 0,10
update table set []=[]
insert into table () values ()
delete from table where ....

数据库事务的隔离机制：
1、可串行化
2、可重复读
3、提交读
4、未提交读

脏读：事务T1读取了其他事务未提交的数据；
不可重复读：前后两次读取的结果不一致；
幻读：事务T1读取数据后，事务T2插入了一行记录，事务T1再次读取后就看到了T2的这行数据。

数据库引擎：
1、InnoDB：事务安全型的，行级锁定，必须要设置主键，表文件就是索引文件，不支持全文类型索引
2、MyISAM：非事务安全型的，表级锁定，不一定要设置主键，索引文件和表文件是分离的，支持全文类型索引

可达性分析算法中可作为GCRoots对象的有：
1、方法区中的静态成员
2、方法区中的常量引用对象
3、java虚拟机栈中的对象
4、java本地方法区中本地方法引用的对象

什么时候进行Minor GC和Full GC

大对象直接进去老年代、当对象的年龄超过阈值时进入老年代

G1垃圾收集器的优点：
1、对垃圾回收划分优先级
2、最大的优点是进行空间整合，减少了内存碎片的产生，也降低了GC的频率
3、让使用者可以指定停顿时间

类的加载机制：
双亲委派模型：
1、启动类加载器；加载java_home\lib
2、扩展类加载器；加载java_home\lib\ext
3、应用程序类加载器；加载class_path
4、用户自定义类加载器；
当加载器收到类加载的请求时，首先将该请求委派给其父类加载器去加载，每一个层次的类加载器都是如此，
只有当父类加载器无法加载该类时，子加载器才会尝试自己加载；

死锁的产生条件：
1、互斥条件
2、不可剥夺条件
3、请求保持条件
4、循环等待条件

死锁的预防：破坏其中的任何一个条件都行

死锁的避免：银行家算法、安全序列

死锁的解决：将某些进程挂起

进程间通讯的机制：
1、管道：半双工的
2、命名管道：
3、信号量：
4、消息队列：
5、Socket
6、共享内存

常用的hash算法：
1、加法hash
2、乘法hash
3、除法hash
4、查表hash
5、混合hash

解决hash冲突：
1、开放定址法：Hi(key) = (H(key) + di) % m
2、链地址法
3、建立公共溢出区
4、再哈希法

线程的生命周期：
1、New
2、Runnable
3、Blocked
4、Waiting
5、Time_waiting
6、terminated

线程池的状态：
1、Running
2、shutdown
3、stop
4、terminated

线程池的基本参数：
1、核心线程数量
2、最大线程数量
3、线程存活时间，如果线程的空闲时间大于该时间，则标记该线程为可回收，如果线程池中的线程大于核心线程数量，则回收该线程，当然核心线程在默认情况下是不会被回收的。
4、任务队列
5、饱和策略，只有在使用了有界队列时才会生效，如果任务队列已满，且没有空闲的工作线程，
则会执行饱和策略


如果有一个进程挂起了，如何使用工具查询原因？
可以使用javaCore了解线程的运行状况。

你知道的开源协议有哪些？
MPL协议：免费发布，免费修改，但要求修改后的代码版权归软件的发起者；
BSD开源协议：有很大的自由；
Apache license 2.0：和BSD很类似；
GPL：